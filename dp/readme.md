动态规划（Dynamic Programming，DP），虽然抽象后进行求解的思路并不复杂，但具体的形式千差万别，找出问题的子结构以及通过子结构重新构造最优解的过程
很难统一，并不像回溯法具有解决绝大多数问题的方案。本文主要是对一些常见的动态规划题目的收集。

动态规划求解的一般思路： 
1.判断问题的子结构（也可看作状态），当具有最优子结构时，动态规划可能适用。
2.求解重叠子问题。一个递归算法不断地调用同一问题，递归可以转化为查表从而利用子问题的解。分治法则不同，每次递归都产生新的问题。
3.重新构造一个最优解。

实例：
1.找硬币：有面值1，2，5的硬币，求组合价值为n的最小硬币数。
  首先分析边界条件或特殊情况：n=1,2,3,4,5找全边界值，则求最小值f(n) = min{f(n-j)} + 1，其中j=1，2，5
  
2.最大数的苹果：一个矩形区域被划分为N*M个小矩形格子，在格子(i,j)中有A[i][j]个苹果。现在从左上角的格子(1,1)出发，要求每次只能向右走一步或向下走一步，
最后到达(N,M)，每经过一个格子就把其中的苹果全部拿走。请找出能拿到最多苹果数的路线。  
  状态方程：M(i,j) = max{M(i-1,j), M(i,j-1)} + A(i,j)
  边界条件：当i==j==1时，M(i,j)=A(i,j);当i==1且j!=1时，M(i,j)=M(i,j-1)+A(i,j);当i!=1且j==1时，M(i,j)=M(i-1,j)+A(i,j)
  
3.两个字符串的相似度、编辑距离（edit distance）：对于序列S和T，它们之间距离定义为：对二者其一进行几次以下的操作(1)删去一个字符；(2)插入一个字符；(3)改变一个字符。每进行一次操作，计数增加1。将S和T变为同一个字符串的最小计数即为它们的距离。
  状态方程：当s[i] == s[j] 时，D(i,j) = D(i-1,j-1)；当s[i] != s[j]时，D(i,j) = min{D(i-1,j-1), D(i,j-1), D(i-1,j)} + 1
  边界条件：计算中有一个串为空串时距离里等于另一个字符串的长度
 
4.最长公共子序列：
状态方程：M(i,j)=M(i-1,j-1)+1 如果s1[i]==s2[j],否则M(i,j)=max{M(i-1,j), M(i, j-1)}
边界条件：M(0,j)=M(i,0)=0

5.最长递增子序列：s[i]为一个序列，lis[]记录最长子序列长度
状态方程：lis[i] = lis[j] + 1,i={1,2,3,...,len(s)},j={1,2,3,...,i},如果s[i]>s[j]并且lis[i]<lis[j]+1
边界条件：lis[i] = 0

6.最大连续子序列之和：从头到尾扫描数组，扫描至array[i]时，可能的最长子向量有两种情况：要么在前i-1个元素中，要么以i结尾。前者的大小记为maxsofar，后者记为maxendinghere。
状态方程： maxendinghere = maxnum(maxendinghere + array[i],array[i]);maxsofar = maxnum(maxsofar,maxendinghere);

7.最大连续子序列之积：（1）若全为正，则可以去对数，等同于最大连续子序列之和；（2）若有正有负，得保存正负两个中间结果
		maxTemp = max(maxCur*s[i], max(minCur*s[i], s[i]))
		minTemp = min(minCur*s[i], min(minCur*s[i], s[i]))
    
8.矩阵连乘最小计算次数：
状态方程：找在第i个和第j个矩阵之间最少得计算次数，即在i和j之间找到k，使M(i,j)最小，M(i,j)=M(i,k)+M(k+1,j)+p(i)*p(k+1)*p(j+1)

9.01背包问题：声明一个 大小为  m[n][c] 的二维数组，m[ i ][ j ] 表示 在面对第 i 件物品，且背包容量为  j 时所能获得的最大价值 ，那么我们可以很容易分析得出 m[i][j] 的计算方法，（1）. j < w[i] 的情况，这时候背包容量不足以放下第 i 件物品，只能选择不拿m[ i ][ j ] = m[ i-1 ][ j ]；（2）. j>=w[i] 的情况，这时背包容量可以放下第 i 件物品，我们就要考虑拿这件物品是否能获取更大的价值。如果拿取，m[ i ][ j ]=m[ i-1 ][ j-w[ i ] ] + v[ i ]。 这里的m[ i-1 ][ j-w[ i ] ]指的就是考虑了i-1件物品，背包容量为j-w[i]时的最大价值，也是相当于为第i件物品腾出了w[i]的空间。如果不拿，m[ i ][ j ] = m[ i-1 ][ j ] , 同（1）
状态方程：if(j>=w[i])：m[i][j]=max(m[i-1][j],m[i-1][j-w[i]]+v[i]); else: m[i][j]=m[i-1][j];
