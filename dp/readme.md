动态规划（Dynamic Programming，DP），虽然抽象后进行求解的思路并不复杂，但具体的形式千差万别，找出问题的子结构以及通过子结构重新构造最优解的过程
很难统一，并不像回溯法具有解决绝大多数问题的方案。本文主要是对一些常见的动态规划题目的收集。

动态规划求解的一般思路： 
1.判断问题的子结构（也可看作状态），当具有最优子结构时，动态规划可能适用。
2.求解重叠子问题。一个递归算法不断地调用同一问题，递归可以转化为查表从而利用子问题的解。分治法则不同，每次递归都产生新的问题。
3.重新构造一个最优解。

实例：
1.找硬币：有面值1，2，5的硬币，求组合价值为n的最小硬币数。
  首先分析边界条件或特殊情况：n=1,2,3,4,5找全边界值，则求最小值f(n) = min{f(n-j)} + 1，其中j=1，2，5
  
2.最大数的苹果：一个矩形区域被划分为N*M个小矩形格子，在格子(i,j)中有A[i][j]个苹果。现在从左上角的格子(1,1)出发，要求每次只能向右走一步或向下走一步，
最后到达(N,M)，每经过一个格子就把其中的苹果全部拿走。请找出能拿到最多苹果数的路线。  
  状态方程：M(i,j) = max{M(i-1,j), M(i,j-1)} + A(i,j)
  边界条件：当i==j==1时，M(i,j)=A(i,j);当i==1且j!=1时，M(i,j)=M(i,j-1)+A(i,j);当i!=1且j==1时，M(i,j)=M(i-1,j)+A(i,j)
  
3.两个字符串的相似度、编辑距离（edit distance）：对于序列S和T，它们之间距离定义为：对二者其一进行几次以下的操作(1)删去一个字符；(2)插入一个字符；(3)改变一个字符。每进行一次操作，计数增加1。将S和T变为同一个字符串的最小计数即为它们的距离。
  状态方程：当s[i] == s[j] 时，D(i,j) = D(i-1,j-1)；当s[i] != s[j]时，D(i,j) = min{D(i-1,j-1), D(i,j-1), D(i-1,j)} + 1
  边界条件：计算中有一个串为空串时距离里等于另一个字符串的长度
  
